%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}


\title{py\sphinxhyphen{}lmd}
\date{Feb 04, 2022}
\release{1.0.0}
\author{Georg Wallmann, Sophia MÃ¤dler and Niklas Schmacke}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxShadowBox}
\sphinxstyletopictitle{Table of Contents}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{index:id1}}{\hyperref[\detokenize{index:overview}]{\sphinxcrossref{Overview}}}

\end{itemize}
\end{sphinxShadowBox}

\sphinxAtStartPar
Welcome to the show


\chapter{Quick Start}
\label{\detokenize{pages/quickstart:quick-start}}\label{\detokenize{pages/quickstart::doc}}

\section{Installation from Github}
\label{\detokenize{pages/quickstart:installation-from-github}}
\sphinxAtStartPar
To install the py\sphinxhyphen{}lmd library clone the Github repository and use pip to install the library in your current environment. It is recommended to use the library with a Conda environment. Please make sure that the package is installed editable like described. Otherwise static glyph files might not be available.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{HornungLab}\PYG{o}{/}\PYG{n}{py}\PYG{o}{\PYGZhy{}}\PYG{n}{lmd}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Once installed the modules can be loaded as following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\end{sphinxVerbatim}


\section{Generating Shapes}
\label{\detokenize{pages/quickstart:generating-shapes}}
\sphinxAtStartPar
As first example we will create a cutting data for a rectangle and visualize it. First we need to think of a calibration points for our coordinate system.  The calibration points are specified as Numpy array and should have the shape \sphinxtitleref{(3, 2)}. When calibrating the file on the Leica LMD after loading the file, the order of selecting the calibration points is the same as the order of points set here. If no other orientation transform has been specified,  the calibration points are defined in the \sphinxtitleref{(x, y)} coordinate system. More on the usage of different coordinate systems can be found under XXX.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                        \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,}
                        \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
With these calibration coordinates we can create our {\hyperref[\detokenize{pages/modules:lmd.lib.Collection}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Collection}}}}} object. The {\hyperref[\detokenize{pages/modules:lmd.lib.Collection}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Collection}}}}} is the base object for creating cutting data and holds a list of {\hyperref[\detokenize{pages/modules:lmd.lib.Shape}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Shape}}}}} objects. Furthermore, it allows to read and write the Leica LMD XML format and handles the coordinate system.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can then create our first rectangle by using the {\hyperref[\detokenize{pages/modules:lmd.lib.Shape}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Shape}}}}} object and passing it to our collection by using the {\hyperref[\detokenize{pages/modules:lmd.lib.Collection.add_shape}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_shape}}}}} method. For creating the Shape object we need to pass the vertices as Numpy array. List of vertices should always be closed with the last vertex equaling the first one.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rectangle\PYGZus{}coordinates} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{rectangle} \PYG{o}{=} \PYG{n}{Shape}\PYG{p}{(}\PYG{n}{rectangle\PYGZus{}coordinates}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{add\PYGZus{}shape}\PYG{p}{(}\PYG{n}{rectangle}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can visualize our collection with the {\hyperref[\detokenize{pages/modules:lmd.lib.Collection.plot}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot}}}}} method. Using the \sphinxtitleref{calibration = True} parameter will include the calibration coordinates in the plot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig1}.png}

\sphinxAtStartPar
We can generate a second shape in form of a triangle. This time we will be using the {\hyperref[\detokenize{pages/modules:lmd.lib.Collection.new_shape}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{new\_shape}}}}} method of the collection object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{triangle\PYGZus{}coordinates} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{70}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{70}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{70}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{new\PYGZus{}shape}\PYG{p}{(}\PYG{n}{triangle\PYGZus{}coordinates}\PYG{p}{)}

\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig2}.png}

\sphinxAtStartPar
We can then export and save our collection of shapes into xml cutting data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{first\PYGZus{}collection.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZlt{}?xml version=\PYGZsq{}1.0\PYGZsq{} encoding=\PYGZsq{}UTF\PYGZhy{}8\PYGZsq{}?\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}ImageData}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}GlobalCoordinates}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/GlobalCoordinates\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}X\PYGZus{}CalibrationPoint\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}CalibrationPoint\PYGZus{}1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}CalibrationPoint\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}CalibrationPoint\PYGZus{}1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}X\PYGZus{}CalibrationPoint\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}CalibrationPoint\PYGZus{}2\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}CalibrationPoint\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}10000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}CalibrationPoint\PYGZus{}2\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}X\PYGZus{}CalibrationPoint\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}5000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}CalibrationPoint\PYGZus{}3\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}CalibrationPoint\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}5000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}CalibrationPoint\PYGZus{}3\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}ShapeCount}\PYG{n+nt}{\PYGZgt{}}2\PYG{n+nt}{\PYGZlt{}/ShapeCount\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Shape\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}PointCount}\PYG{n+nt}{\PYGZgt{}}5\PYG{n+nt}{\PYGZlt{}/PointCount\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}1\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}1\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}2\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}2\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}3\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}3\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}4}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}4\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}4}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}4\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}5}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}5\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}5}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}5\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/Shape\PYGZus{}1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Shape\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}PointCount}\PYG{n+nt}{\PYGZgt{}}4\PYG{n+nt}{\PYGZlt{}/PointCount\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}1\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}7000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}1\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}2\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}7000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}2\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}3\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}10000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}3\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}4}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}4\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}4}\PYG{n+nt}{\PYGZgt{}}7000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}4\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/Shape\PYGZus{}2\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/ImageData\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Looking at the generated xml output we can see the calibration points and different shapes. Furthermore, we see that the coordinate system has been scaled by a linear scaling factor. As all points are defined as integers scaling by a linear factor allows to use decimal numbers as coordinates.


\section{Using the py\sphinxhyphen{}lmd tools}
\label{\detokenize{pages/quickstart:using-the-py-lmd-tools}}
\sphinxAtStartPar
A lot uf usefull functionality is included in the tools module of the py\sphinxhyphen{}lmd package. We will first use the rectangle functionality to create rectangle shapes fast.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After initiating the coordinate system we can use the {\hyperref[\detokenize{pages/modules:lmd.tools.rectangle}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rectangle()}}}}} helper function to create a {\hyperref[\detokenize{pages/modules:lmd.lib.Shape}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Shape}}}}} object with a rectangle with specified size and position.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}square} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{rectangle}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{add\PYGZus{}shape}\PYG{p}{(}\PYG{n}{my\PYGZus{}square}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig3}.png}

\sphinxAtStartPar
We can further specify an angle of rotation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}square} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{rectangle}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{add\PYGZus{}shape}\PYG{p}{(}\PYG{n}{my\PYGZus{}square}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig4}.png}


\section{Numbers and Letters}
\label{\detokenize{pages/quickstart:numbers-and-letters}}
\sphinxAtStartPar
The py\sphinxhyphen{}lmd tools offer a limited support for numbers and some capital letters. The following glyphs are available: \sphinxtitleref{ABCDEFGHI0123456789\sphinxhyphen{}\_}. They were included in the package as they allow for the development of more consistent calibration and sample indexing.In screens with multiple slides, samples can be unambiguously identified from imaged data.

\sphinxAtStartPar
We will first use \sphinxcode{\sphinxupquote{glyphs()}} to load single glyphs. The glyphs are included in the py\sphinxhyphen{}lmd package as SVG files and are loaded by the {\hyperref[\detokenize{pages/modules:lmd.lib.Collection.svg_to_lmd}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svg\_to\_lmd()}}}}} into an uncalibrated {\hyperref[\detokenize{pages/modules:lmd.lib.Collection}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Collection}}}}}. This uncalibrated collection is returned and can be joined with a calibrated collection with the {\hyperref[\detokenize{pages/modules:lmd.lib.Collection.join}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{join()}}}}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{digit\PYGZus{}1} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{glyph}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{digit\PYGZus{}1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig7}.png}

\sphinxAtStartPar
By default glyphs and text have a height of ten units and are located by the top left corner. We can use the \sphinxtitleref{offset} and \sphinxtitleref{multiplier} parameters to change the size and position.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digit\PYGZus{}2} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{glyph}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{offset} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{multiplier} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{digit\PYGZus{}2}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig8}.png}

\sphinxAtStartPar
Like with the previous rectangle example we can also use the \sphinxtitleref{rotation} parameter to set a clockwise rotation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{glyph\PYGZus{}A} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{glyph}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{glyph\PYGZus{}A}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig9}.png}


\section{Text}
\label{\detokenize{pages/quickstart:text}}
\sphinxAtStartPar
Next to individual glyphs the {\hyperref[\detokenize{pages/modules:lmd.tools.text}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{text()}}}}} method can be used to write text with specified position, size and rotation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{identifier\PYGZus{}1} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0456\PYGZus{}B2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{identifier\PYGZus{}1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig10}.png}


\section{Different Coordinate Systems}
\label{\detokenize{pages/quickstart:different-coordinate-systems}}
\sphinxAtStartPar
The coordinates for the Leica LMD are defined as \sphinxtitleref{(x, y)} coordinates with the x\sphinxhyphen{}axis extending to the right and the y\sphinxhyphen{}axis extending to the top. All cutting data should exist in this coordinate system and should be calibrated accordingly. When cutting data is generated based on whole slide images we have to keep in mind that images are often indexed differently. Images in Fiji or Numpy are indexed as \sphinxtitleref{(row, column)} with the rows extending downwards and the columns extending to the right. If we want to identify positions in image data \sphinxhyphen{} like calibration crosses or single cells \sphinxhyphen{} we have to translate their position in the \sphinxtitleref{(row, column)} format to the \sphinxtitleref{(x, y)} format.

\noindent\sphinxincludegraphics{{py-lmd-figures-01}.png}

\sphinxAtStartPar
The py\sphinxhyphen{}lmd library has been designed in a way which allows to transform the coordinate system prior to saving. Therefore one can specify all coordinates in the image coordinate system and rely on the library to handle the transformation. In this case the \sphinxtitleref{orientation\_transform} attribute needs to be set when the Collection is created.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}
\PYG{n}{collection}\PYG{o}{.}\PYG{n}{orientation\PYGZus{}transform} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case  all coordinates for calibration points and shapes can be set in form of \sphinxtitleref{(row, column)} coordinates. The orientation transform is only applied when the Collection is saved or, if desired, when the Collection is plotted.


\chapter{Modules}
\label{\detokenize{pages/modules:modules}}\label{\detokenize{pages/modules::doc}}

\section{lmd.lib}
\label{\detokenize{pages/modules:lmd-lib}}

\subsection{Collection}
\label{\detokenize{pages/modules:collection}}\index{Collection (class in lmd.lib)@\spxentry{Collection}\spxextra{class in lmd.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{lmd.lib.}}\sphinxbfcode{\sphinxupquote{Collection}}}{\emph{\DUrole{n}{calibration\_points}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Class which is used for creating shape collections for the Leica LMD6 \& 7. Contains a coordinate system defined by calibration points and a collection of various shapes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calibration\_points}} \textendash{} Calibration coordinates in the form of \((3, 2)\).

\end{description}\end{quote}
\index{shapes (lmd.lib.Collection attribute)@\spxentry{shapes}\spxextra{lmd.lib.Collection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.shapes}}\pysigline{\sphinxbfcode{\sphinxupquote{shapes}}}
\sphinxAtStartPar
Contains all shapes which are part of the collection.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
List{[}{\hyperref[\detokenize{pages/modules:lmd.lib.Shape}]{\sphinxcrossref{Shape}}}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{calibration\_points (lmd.lib.Collection attribute)@\spxentry{calibration\_points}\spxextra{lmd.lib.Collection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.calibration_points}}\pysigline{\sphinxbfcode{\sphinxupquote{calibration\_points}}}
\sphinxAtStartPar
Calibration coordinates in the form of \((3, 2)\).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
Optional{[}np.ndarray{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{orientation\_transform (lmd.lib.Collection attribute)@\spxentry{orientation\_transform}\spxextra{lmd.lib.Collection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.orientation_transform}}\pysigline{\sphinxbfcode{\sphinxupquote{orientation\_transform}}}
\sphinxAtStartPar
defines transformations performed on the provided coordinate system prior to export as XML. This orientation\_transform is always applied to shapes when there is no individual orienation\_transform provided.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_shape() (lmd.lib.Collection method)@\spxentry{add\_shape()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.add_shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_shape}}}{\emph{\DUrole{n}{shape}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{pages/modules:lmd.lib.Shape}]{\sphinxcrossref{lmd.lib.Shape}}}}}}{}
\sphinxAtStartPar
Add a new shape to the collection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shape}} \textendash{} Shape which should be added.

\end{description}\end{quote}

\end{fulllineitems}

\index{join() (lmd.lib.Collection method)@\spxentry{join()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.join}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{join}}}{\emph{\DUrole{n}{collection}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{pages/modules:lmd.lib.Collection}]{\sphinxcrossref{lmd.lib.Collection}}}}}}{}
\sphinxAtStartPar
Join the collection with the shapes of a different collection. The calibration markers of the current collection are kept. Please keep in mind that coordinate systems and calibration points must be compatible for correct joining of collections.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{collection}} \textendash{} Collection which should be joined with the current collection object.

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (lmd.lib.Collection method)@\spxentry{load()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{\emph{\DUrole{n}{file\_location}\DUrole{p}{:} \DUrole{n}{str}}}{}
\sphinxAtStartPar
Can be used to load a shape file from XML. Both, XMLs generated with py\sphinxhyphen{}lmd and the Leica software can be used.
:param file\_location: File path pointing to the XML file.

\end{fulllineitems}

\index{new\_shape() (lmd.lib.Collection method)@\spxentry{new\_shape()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.new_shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{new\_shape}}}{\emph{\DUrole{n}{points}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{well}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Directly create a new Shape in the current collection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{points}} \textendash{} Array or list of lists in the shape of \sphinxtitleref{(N,2)}. Contains the points of the polygon forming a shape.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{well}} \textendash{} Well in which to sort the shape after cutting. For example A1, A2 or B3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of the shape.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (lmd.lib.Collection method)@\spxentry{plot()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{\DUrole{n}{calibration}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{mode}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}line\textquotesingle{}}}, \emph{\DUrole{n}{fig\_size}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{(5, 5)}}, \emph{\DUrole{n}{apply\_orientation\_transform}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{apply\_scale}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{save\_name}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
\sphinxAtStartPar
This function can be used to plot all shapes of the corresponding shape collection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calibration}} \textendash{} Controls wether the calibration points should be plotted as crosshairs. Deactivating the crosshairs will result in the size of the canvas adapting to the shapes. Can be especially usefull for small shapes or debugging.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fig\_size}} \textendash{} Defaults to \((10, 10)\) Controls the size of the matplotlib figure. See \sphinxhref{https://matplotlib.org/stable/api/\_as\_gen/matplotlib.pyplot.figure.html\#matplotlib-pyplot-figure}{matplotlib documentation} for more information.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{apply\_orientation\_transform}} \textendash{} Define wether the orientation transform should be applied before plotting.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{(}}\sphinxstyleliteralstrong{\sphinxupquote{Optional}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{str}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{save\_name}}) \textendash{} None): Specify a filename  for saving the generated figure. By default \sphinxtitleref{None} is provided which will not save a figure.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} None): Specify a filename  for saving the generated figure. By default \sphinxtitleref{None} is provided which will not save a figure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (lmd.lib.Collection method)@\spxentry{save()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{file\_location}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{encoding}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}utf\sphinxhyphen{}8\textquotesingle{}}}}{}
\sphinxAtStartPar
Can be used to save the shape collection as XML file.

\sphinxAtStartPar
file\_location: File path pointing to the XML file.

\end{fulllineitems}

\index{svg\_to\_lmd() (lmd.lib.Collection method)@\spxentry{svg\_to\_lmd()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.svg_to_lmd}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{svg\_to\_lmd}}}{\emph{\DUrole{n}{file\_location}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{{[}0, 0{]}}}, \emph{\DUrole{n}{divisor}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{multiplier}\DUrole{o}{=}\DUrole{default_value}{60}}, \emph{\DUrole{n}{rotation\_matrix}\DUrole{o}{=}\DUrole{default_value}{numpy.eye}}, \emph{\DUrole{n}{orientation\_transform}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Can be used to save the shape collection as XML file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_location}} \textendash{} File path pointing to the SVG file.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{orientation\_transform}} \textendash{} Will superseed the global transform of the Collection.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotation\_matrix}} \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Shape}
\label{\detokenize{pages/modules:shape}}\index{Shape (class in lmd.lib)@\spxentry{Shape}\spxextra{class in lmd.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{lmd.lib.}}\sphinxbfcode{\sphinxupquote{Shape}}}{\emph{\DUrole{n}{points}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{well}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{orientation\_transform}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Class for creating a single shape object.
\index{from\_xml() (lmd.lib.Shape method)@\spxentry{from\_xml()}\spxextra{lmd.lib.Shape method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Shape.from_xml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_xml}}}{\emph{\DUrole{n}{root}}}{}
\sphinxAtStartPar
Load a shape from an XML shape node. Used internally for reading LMD generated XML files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{root}} \textendash{} XML input node.

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_xml() (lmd.lib.Shape method)@\spxentry{to\_xml()}\spxextra{lmd.lib.Shape method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Shape.to_xml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_xml}}}{\emph{\DUrole{n}{id}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{orientation\_transform}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{scale}\DUrole{p}{:} \DUrole{n}{int}}}{}
\sphinxAtStartPar
Generate XML shape node needed internally for export.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} Sequential identifier of the shape as used in the LMD XML format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{orientation\_transform}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Pass orientation\_transform which is used if no local orientation transform is set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Scalling factor used to enable higher decimal precision.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If the Shape has a custom orientation\_transform defined, the custom orientation\_transform is applied at this point. If not, the oritenation\_transform passed by the parent Collection is used. This highlights an important difference between the Shape and Collection class. The Collection will always has an orientation transform defined and will use \sphinxtitleref{np.eye(2)} by default. The Shape object can have a orientation\_transform but can also be set to \sphinxtitleref{None} to use the Collection value.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}



\section{lmd.tools}
\label{\detokenize{pages/modules:module-lmd.tools}}\label{\detokenize{pages/modules:lmd-tools}}\index{module@\spxentry{module}!lmd.tools@\spxentry{lmd.tools}}\index{lmd.tools@\spxentry{lmd.tools}!module@\spxentry{module}}\index{ellipse() (in module lmd.tools)@\spxentry{ellipse()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.ellipse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{ellipse}}}{\emph{\DUrole{n}{major\_axis}}, \emph{\DUrole{n}{minor\_axis}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}, \emph{\DUrole{n}{rotation}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{polygon\_resolution}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\sphinxAtStartPar
Get a lmd.lib.Shape for ellipse of choosen dimensions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{major\_axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Major axis of the ellipse. The major axis is defined from the center to the perimeter and therefore half the diameter. The major axis is placed along the x\sphinxhyphen{}axis before rotation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{minor\_axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minor axis of the ellipse. The minor axis is defined from the center to the perimeter and therefore half the diameter. The minor axis is placed along the y\sphinxhyphen{}axis before rotation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the ellipse based on the center given in the form of \sphinxtitleref{(x, y)}. Default value: np.array((0, 0))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotation}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Clockwise rotation in radian.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{polygon\_resolution}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The polygon resolution defines how far the vertices should be spaced on average. A polygon\_resolution of 10 will place a vertex on average every ten units.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Shape which contains the ellipse.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{pages/modules:lmd.lib.Shape}]{\sphinxcrossref{lmd.lib.Shape}}}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{my\PYGZus{}ellipse} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{ellipse}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{offset} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,} \PYG{n}{polygon\PYGZus{}resolution} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{add\PYGZus{}shape}\PYG{p}{(}\PYG{n}{my\PYGZus{}ellipse}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{tools.ellipse.example}.png}

\end{fulllineitems}

\index{get\_rotation\_matrix() (in module lmd.tools)@\spxentry{get\_rotation\_matrix()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.get_rotation_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{get\_rotation\_matrix}}}{\emph{\DUrole{n}{angle}\DUrole{p}{:} \DUrole{n}{float}}}{}
\sphinxAtStartPar
Returns a rotation matrix for clockwise rotation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{angle}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Rotation in radian.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Matrix in the shape of (2, 2).

\item[{Return type}] \leavevmode
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{glyph() (in module lmd.tools)@\spxentry{glyph()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.glyph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{glyph}}}{\emph{\DUrole{n}{glyph}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{numpy.array}}, \emph{\DUrole{n}{rotation}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{divisor}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{multiplier}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Get an uncalibrated lmd.lib.Collection for a glyph of interest.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{glyph}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Single glyph as string.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{divisor}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Parameter which determines the resolution when creating a polygon from a SVG. A larger divisor will lead to fewer datapoints for the glyph. Default value: 10

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the glyph based on the top left corner. Default value: np.array((0, 0))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{multiplier}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Scaling parameter for defining the size of the glyph. The default height of a glyph is 10 units. Default value: 1

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Uncalibrated Collection which contains the Shapes for the glyph.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{pages/modules:lmd.lib.Collection}]{\sphinxcrossref{lmd.lib.Collection}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{glyph\_path() (in module lmd.tools)@\spxentry{glyph\_path()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.glyph_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{glyph\_path}}}{\emph{\DUrole{n}{glyph}}}{}
\sphinxAtStartPar
Returns the path for a glyph of interest. Raises a NotImplementedError if an unknown glyph is requested.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{glyph}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Single glyph as string.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Path for the glyph.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{rectangle() (in module lmd.tools)@\spxentry{rectangle()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.rectangle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{rectangle}}}{\emph{\DUrole{n}{width}}, \emph{\DUrole{n}{height}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}, \emph{\DUrole{n}{rotation}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{rotation\_offset}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}}{}
\sphinxAtStartPar
Get a lmd.lib.Shape for rectangle of choosen dimensions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{width}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Width of the rectangle.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the rectangle based on the center. Default value: np.array((0, 0))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotation}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Rotation in radian.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotation\_offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the center of rotation relative to the center of the rectangle. Default value: np.array((0, 0))

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Shape which contains the rectangle.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{pages/modules:lmd.lib.Shape}]{\sphinxcrossref{lmd.lib.Shape}}}

\end{description}\end{quote}

\sphinxAtStartPar
Example:

\end{fulllineitems}

\index{text() (in module lmd.tools)@\spxentry{text()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.text}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{text}}}{\emph{\DUrole{n}{text}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{numpy.array}}, \emph{\DUrole{n}{divisor}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{multiplier}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{rotation}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Get an uncalibrated lmd.lib.Collection for a text.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{text}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Text as string.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{divisor}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Parameter which determines the resolution when creating a polygon from a SVG. A larger divisor will lead to fewer datapoints for the glyph. Default value: 10

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the text based on the top left corner. Default value: np.array((0, 0))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{multiplier}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Scaling parameter for defining the size of the text. The default height of a glyph is 10 units. Default value: 1

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Uncalibrated Collection which contains the Shapes for the text.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{pages/modules:lmd.lib.Collection}]{\sphinxcrossref{lmd.lib.Collection}}}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{identifier\PYGZus{}1} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0456\PYGZus{}B2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{identifier\PYGZus{}1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig10}.png}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{l}
\item\relax\sphinxstyleindexentry{lmd.tools}\sphinxstyleindexpageref{pages/modules:\detokenize{module-lmd.tools}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}