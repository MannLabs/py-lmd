%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}


\title{py\sphinxhyphen{}lmd}
\date{Feb 18, 2022}
\release{1.0.1}
\author{Georg Wallmann, Sophia Mädler and Niklas Schmacke}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxShadowBox}
\sphinxstyletopictitle{Table of Contents}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{index:id1}}{\hyperref[\detokenize{index:overview}]{\sphinxcrossref{Overview}}}

\end{itemize}
\end{sphinxShadowBox}

\sphinxAtStartPar
Welcome to the show


\chapter{Quick Start}
\label{\detokenize{pages/quickstart:quick-start}}\label{\detokenize{pages/quickstart::doc}}

\section{Installation from Github}
\label{\detokenize{pages/quickstart:installation-from-github}}
\sphinxAtStartPar
To install the py\sphinxhyphen{}lmd library clone the Github repository and use pip to install the library in your current environment. It is recommended to use the library with a Conda environment. Please make sure that the package is installed editable like described. Otherwise static glyph files might not be available.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{HornungLab}\PYG{o}{/}\PYG{n}{py}\PYG{o}{\PYGZhy{}}\PYG{n}{lmd}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Once installed the modules can be loaded as following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\end{sphinxVerbatim}


\section{Generating Shapes}
\label{\detokenize{pages/quickstart:generating-shapes}}
\sphinxAtStartPar
As first example we will create a cutting data for a rectangle and visualize it. First we need to think of a calibration points for our coordinate system.  The calibration points are specified as Numpy array and should have the shape \sphinxtitleref{(3, 2)}. When calibrating the file on the Leica LMD after loading the file, the order of selecting the calibration points is the same as the order of points set here. If no other orientation transform has been specified,  the calibration points are defined in the \sphinxtitleref{(x, y)} coordinate system. More on the usage of different coordinate systems can be found under XXX.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                        \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,}
                        \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
With these calibration coordinates we can create our \sphinxcode{\sphinxupquote{Collection}} object. The \sphinxcode{\sphinxupquote{Collection}} is the base object for creating cutting data and holds a list of \sphinxcode{\sphinxupquote{Shape}} objects. Furthermore, it allows to read and write the Leica LMD XML format and handles the coordinate system.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can then create our first rectangle by using the \sphinxcode{\sphinxupquote{Shape}} object and passing it to our collection by using the \sphinxcode{\sphinxupquote{add\_shape}} method. For creating the Shape object we need to pass the vertices as Numpy array. List of vertices should always be closed with the last vertex equaling the first one.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rectangle\PYGZus{}coordinates} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{rectangle} \PYG{o}{=} \PYG{n}{Shape}\PYG{p}{(}\PYG{n}{rectangle\PYGZus{}coordinates}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{add\PYGZus{}shape}\PYG{p}{(}\PYG{n}{rectangle}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can visualize our collection with the \sphinxcode{\sphinxupquote{plot}} method. Using the \sphinxtitleref{calibration = True} parameter will include the calibration coordinates in the plot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig1}.png}

\sphinxAtStartPar
We can generate a second shape in form of a triangle. This time we will be using the \sphinxcode{\sphinxupquote{new\_shape}} method of the collection object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{triangle\PYGZus{}coordinates} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{70}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{70}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{70}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{new\PYGZus{}shape}\PYG{p}{(}\PYG{n}{triangle\PYGZus{}coordinates}\PYG{p}{)}

\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig2}.png}

\sphinxAtStartPar
We can then export and save our collection of shapes into xml cutting data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{first\PYGZus{}collection.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZlt{}?xml version=\PYGZsq{}1.0\PYGZsq{} encoding=\PYGZsq{}UTF\PYGZhy{}8\PYGZsq{}?\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}ImageData}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}GlobalCoordinates}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/GlobalCoordinates\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}X\PYGZus{}CalibrationPoint\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}CalibrationPoint\PYGZus{}1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}CalibrationPoint\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}CalibrationPoint\PYGZus{}1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}X\PYGZus{}CalibrationPoint\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}CalibrationPoint\PYGZus{}2\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}CalibrationPoint\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}10000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}CalibrationPoint\PYGZus{}2\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}X\PYGZus{}CalibrationPoint\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}5000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}CalibrationPoint\PYGZus{}3\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}CalibrationPoint\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}5000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}CalibrationPoint\PYGZus{}3\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}ShapeCount}\PYG{n+nt}{\PYGZgt{}}2\PYG{n+nt}{\PYGZlt{}/ShapeCount\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Shape\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}PointCount}\PYG{n+nt}{\PYGZgt{}}5\PYG{n+nt}{\PYGZlt{}/PointCount\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}1\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}1\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}2\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}2\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}3\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}3\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}4}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}4\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}4}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}4\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}5}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}5\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}5}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}5\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/Shape\PYGZus{}1\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}Shape\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}PointCount}\PYG{n+nt}{\PYGZgt{}}4\PYG{n+nt}{\PYGZlt{}/PointCount\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}1\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}1}\PYG{n+nt}{\PYGZgt{}}7000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}1\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}2\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}2}\PYG{n+nt}{\PYGZgt{}}7000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}2\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}4000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}3\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}3}\PYG{n+nt}{\PYGZgt{}}10000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}3\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}X\PYGZus{}4}\PYG{n+nt}{\PYGZgt{}}1000\PYG{n+nt}{\PYGZlt{}/X\PYGZus{}4\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Y\PYGZus{}4}\PYG{n+nt}{\PYGZgt{}}7000\PYG{n+nt}{\PYGZlt{}/Y\PYGZus{}4\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}/Shape\PYGZus{}2\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/ImageData\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Looking at the generated xml output we can see the calibration points and different shapes. Furthermore, we see that the coordinate system has been scaled by a linear scaling factor. As all points are defined as integers scaling by a linear factor allows to use decimal numbers as coordinates.


\section{Using the py\sphinxhyphen{}lmd tools}
\label{\detokenize{pages/quickstart:using-the-py-lmd-tools}}
\sphinxAtStartPar
A lot uf usefull functionality is included in the tools module of the py\sphinxhyphen{}lmd package. We will first use the rectangle functionality to create rectangle shapes fast.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After initiating the coordinate system we can use the \sphinxcode{\sphinxupquote{rectangle()}} helper function to create a \sphinxcode{\sphinxupquote{Shape}} object with a rectangle with specified size and position.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}square} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{rectangle}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{add\PYGZus{}shape}\PYG{p}{(}\PYG{n}{my\PYGZus{}square}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig3}.png}

\sphinxAtStartPar
We can further specify an angle of rotation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}square} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{rectangle}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{add\PYGZus{}shape}\PYG{p}{(}\PYG{n}{my\PYGZus{}square}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig4}.png}


\section{Numbers and Letters}
\label{\detokenize{pages/quickstart:numbers-and-letters}}
\sphinxAtStartPar
The py\sphinxhyphen{}lmd tools offer a limited support for numbers and some capital letters. The following glyphs are available: \sphinxtitleref{ABCDEFGHI0123456789\sphinxhyphen{}\_}. They were included in the package as they allow for the development of more consistent calibration and sample indexing.In screens with multiple slides, samples can be unambiguously identified from imaged data.

\sphinxAtStartPar
We will first use \sphinxcode{\sphinxupquote{glyphs()}} to load single glyphs. The glyphs are included in the py\sphinxhyphen{}lmd package as SVG files and are loaded by the \sphinxcode{\sphinxupquote{svg\_to\_lmd()}} into an uncalibrated \sphinxcode{\sphinxupquote{Collection}}. This uncalibrated collection is returned and can be joined with a calibrated collection with the \sphinxcode{\sphinxupquote{join()}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{digit\PYGZus{}1} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{glyph}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{digit\PYGZus{}1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig7}.png}

\sphinxAtStartPar
By default glyphs and text have a height of ten units and are located by the top left corner. We can use the \sphinxtitleref{offset} and \sphinxtitleref{multiplier} parameters to change the size and position.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digit\PYGZus{}2} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{glyph}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{offset} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{multiplier} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{digit\PYGZus{}2}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig8}.png}

\sphinxAtStartPar
Like with the previous rectangle example we can also use the \sphinxtitleref{rotation} parameter to set a clockwise rotation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{glyph\PYGZus{}A} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{glyph}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{glyph\PYGZus{}A}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig9}.png}


\section{Text}
\label{\detokenize{pages/quickstart:text}}
\sphinxAtStartPar
Next to individual glyphs the \sphinxcode{\sphinxupquote{text()}} method can be used to write text with specified position, size and rotation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{identifier\PYGZus{}1} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0456\PYGZus{}B2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{identifier\PYGZus{}1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig10}.png}


\chapter{Using Segmented Images}
\label{\detokenize{pages/segmentation_loader:using-segmented-images}}\label{\detokenize{pages/segmentation_loader::doc}}

\section{Background}
\label{\detokenize{pages/segmentation_loader:background}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen,height=400\sphinxpxdimen]{{watershed}.png}}

\sphinxAtStartPar
Although the py\sphinxhyphen{}lmd package is meant to serve as framework for creating your own workflows, generating cutting data based on segmentations is the central application of this package. When biological images are segmented, every pixel receives a class or label. Labels can be used to identify single cells and distinguish them from the background or can categorize cells or areas based on phenotypes, functions or location.

\sphinxAtStartPar
In the following example we will assume that a segmentation was performed to assign labels to individual cells and distinguish their cytosol from the background. The procedures are though applicable to all types of labels.

\sphinxAtStartPar
As this process is so central to the usage of the Leica LMD, the \sphinxcode{\sphinxupquote{SegmentationLoader}} can be used to create cutting data based on segmentation data. The workflow was specifically designed to work with whole slide images, as large as the LMD membrane slides, and large numbers of single cells. Therefore, different processing steps are included which optimize single cell shapes and decrease overall cutting time.


\section{Different Coordinate Systems}
\label{\detokenize{pages/segmentation_loader:different-coordinate-systems}}
\sphinxAtStartPar
Using images to generate cutting data with the py\sphinxhyphen{}lmd package makes it necessary to transform the image coordinate system to the Leica LMD coordinate system. Although this functionality is part of the package, it is important to highlight the differences in the coordinate systems and to keep in mind what coordinate system is used when calibration points are determined from image data.

\sphinxAtStartPar
The coordinates for the Leica LMD are defined as \sphinxtitleref{(x, y)} coordinates with the x\sphinxhyphen{}axis extending to the right and the y\sphinxhyphen{}axis extending to the top. All cutting data should exist in this coordinate system and should be calibrated accordingly. When cutting data is generated based on whole slide images we have to keep in mind that images are often indexed differently. Images in Fiji or Numpy are indexed as \sphinxtitleref{(row, column)} with the rows extending downwards and the columns extending to the right. If we want to identify positions in image data \sphinxhyphen{} like calibration crosses or single cells \sphinxhyphen{} we have to translate their position in the \sphinxtitleref{(row, column)} format to the \sphinxtitleref{(x, y)} format.

\noindent\sphinxincludegraphics{{py-lmd-figures-01}.png}

\sphinxAtStartPar
The py\sphinxhyphen{}lmd library has been designed in a way which allows to transform the coordinate system prior to saving. Therefore one can specify all coordinates in the image coordinate system and rely on the library to handle the transformation. In this case the \sphinxtitleref{orientation\_transform} attribute needs to be set when the Collection is created.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}
\PYG{n}{collection}\PYG{o}{.}\PYG{n}{orientation\PYGZus{}transform} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case  all coordinates for calibration points and shapes can be set in form of \sphinxtitleref{(row, column)} coordinates. The orientation transform is only applied when the Collection is saved or, if desired, when the Collection is plotted.


\section{Getting started with the SegmentationLoader}
\label{\detokenize{pages/segmentation_loader:getting-started-with-the-segmentationloader}}
\sphinxAtStartPar
Before we can start with the \sphinxcode{\sphinxupquote{SegmentationLoader}}, we have to load our image which contains the labels for our cells. The segmentation loader expects a numpy array of integers where the background is assigned to label 0. There are no further restrictions to the shape or number of labels other than being continuos. All pixel with a certain label need to be in contact with each other. Functional labels which assign cells based on the cell type must be converted.

\sphinxAtStartPar
As example we will use the cytosol segmentation seen above which can be found under \sphinxtitleref{notebooks/Image\_Segmentation/segmentation\_cytosol.tiff}. First, we will load this image and convert it to a numpy array.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}

\PYG{n}{im} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{segmentation\PYGZus{}cytosol.tiff}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{segmentation} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{im}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{uint32}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Based on this segmentation we have to select group of cells. These groups can be assigned to separate wells and intersecting shapes and cutting paths will be optimized separately for every group. In our case, all cells will be selected and assigned to the same well A1.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{all\PYGZus{}classes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{segmentation}\PYG{p}{)}
\PYG{n}{cell\PYGZus{}sets} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{classes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{all\PYGZus{}classes}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{well}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we need to specify the calibration points which were identified in the image and the coordinate transform which should be applied. By default, the \sphinxcode{\sphinxupquote{SegmentationLoader}} will read all coordinates as \sphinxtitleref{(row, column)} based on the top left origin. Therefore, the calibration points should be specified in the same way.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{loader\PYGZus{}config} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orientation\PYGZus{}transform}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can now create an instance of the \sphinxcode{\sphinxupquote{SegmentationLoader}} and generate the cutting data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{SegmentationLoader}
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{SegmentationLoader}\PYG{p}{(}\PYG{n}{config} \PYG{o}{=} \PYG{n}{loader\PYGZus{}config}\PYG{p}{)}
\PYG{n}{shape\PYGZus{}collection} \PYG{o}{=} \PYG{n}{sl}\PYG{p}{(}\PYG{n}{segmentation}\PYG{p}{,}
                    \PYG{n}{cell\PYGZus{}sets}\PYG{p}{,}
                    \PYG{n}{calibration\PYGZus{}points}\PYG{p}{)}

\PYG{n}{shape\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fig\PYGZus{}size} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{segmentation1}.png}


\section{Overview of Configuration}
\label{\detokenize{pages/segmentation_loader:overview-of-configuration}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Overview of Configuration Parameters.}\label{\detokenize{pages/segmentation_loader:id1}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{10}{40}|\X{5}{40}|\X{25}{40}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Parameter
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{shape\_dilation}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0}}
&
\sphinxAtStartPar
dilation of the cutting mask in pixel before intersecting shapes in a selection group are merged
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{shape\_erosion}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0}}
&
\sphinxAtStartPar
erosion of the cutting mask in pixel before intersecting shapes in a selection group are merged
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{binary\_smoothing}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{3}}
&
\sphinxAtStartPar
Cutting masks are transformed by binary dilation and erosion
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution\_smoothing}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{15}}
&
\sphinxAtStartPar
number of datapoints which are averaged for smoothing. The resolution of datapoints is twice as high as the resolution of pixels.
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poly\_compression\_factor}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{30}}
&
\sphinxAtStartPar
fold reduction of datapoints for compression
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{path\_optimization}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"hilbert"}}
&
\sphinxAtStartPar
Optimization of the cutting path inbetween shapes. Optimized paths improve the cutting time and the microscopes focus. valid options are \sphinxcode{\sphinxupquote{{[}"none", "hilbert", "greedy"{]}}}
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hilbert\_p}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{7}}
&
\sphinxAtStartPar
Paramter required for hilbert curve based path optimization. Defines the order of the hilbert curve used, which needs to be tuned with the total cutting area.
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{greedy\_k}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{20}}
&
\sphinxAtStartPar
Parameter required for greedy path optimization. Instead of a global distance matrix, the k nearest neighbours are approximated. The optimization problem is then greedily solved for the known set of nearest neighbours until the first set of neighbours is exhausted.Established edges are then removed and the nearest neighbour approximation is recursivly repeated.
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{distance\_heuristic}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{300}}
&
\sphinxAtStartPar
Overlapping shapes are merged based on a nearest neighbour heuristic. All selected shapes closer than distance\_heuristic pixel are checked for overlap.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
To be extended…

\sphinxAtStartPar
Here’s a grid table followed by a simple table:

\sphinxAtStartPar
\sphinxstylestrong{Order of processing:}

\sphinxAtStartPar
shape\_dilation
shape\_erosion
join\_intersecting

\sphinxAtStartPar
binary\_smoothing
binary\_fill\_holes
convolution\_smoothing
poly\_compression

\sphinxAtStartPar
path optimization


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
\sphinxstyletheadfamily \sphinxAtStartPar
\sphinxstylestrong{convolution\_smoothing}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
\sphinxAtStartPar
Smooth the polygon by applying a circular, linear convolution of given size.
The default convolution kernel with \sphinxcode{\sphinxupquote{n}} elements is \sphinxcode{\sphinxupquote{{[}1/n, 1/n, ... , 1/n{]}}}.
By default a value of 15 is used. Values below 3 are not recommended.
In contrast to \sphinxcode{\sphinxupquote{binary\_smoothing}}, \sphinxcode{\sphinxupquote{convolution\_smoothing}} does not increase
the convex hull of the shape. When there are many deep recessions in the shape
\sphinxcode{\sphinxupquote{convolution\_smoothing}} might not be able to smooth these out and
\sphinxcode{\sphinxupquote{binary\_smoothing}} should be used. \sphinxcode{\sphinxupquote{convolution\_smoothing}} does not change the number
of vertices in the polygon of a shape. Please see \sphinxcode{\sphinxupquote{poly\_compression\_factor}}.
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution\_smoothing: 1}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution\_smoothing: 40}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution\_smoothing: 80}}
\\
\hline
\noindent\sphinxincludegraphics{{conv1}.png}
&
\noindent\sphinxincludegraphics{{conv40}.png}
&
\noindent\sphinxincludegraphics{{conv80}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
\sphinxstyletheadfamily \sphinxAtStartPar
\sphinxstylestrong{binary\_smoothing}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
\sphinxAtStartPar
Smooth the polygon by applying a circular, linear convolution of given size.
The default convolution kernel with \sphinxcode{\sphinxupquote{n}} elements is \sphinxcode{\sphinxupquote{{[}1/n, 1/n, ... , 1/n{]}}}.
In contrast to \sphinxcode{\sphinxupquote{binary\_smoothing}}, \sphinxcode{\sphinxupquote{convolution\_smoothing}} does not increase
the convex hull of the shape. When there are many deep recessions in the shape
\sphinxcode{\sphinxupquote{convolution\_smoothing}} might not be able to smooth these out and
\sphinxcode{\sphinxupquote{binary\_smoothing}} should be used. \sphinxcode{\sphinxupquote{convolution\_smoothing}} does not change the number
of vertices in the polygon of a shape. Please see \sphinxcode{\sphinxupquote{poly\_compression\_factor}}.
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution\_smoothing: 1}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution\_smoothing: 40}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convolution\_smoothing: 80}}
\\
\hline
\noindent\sphinxincludegraphics{{bin0}.png}
&
\noindent\sphinxincludegraphics{{bin15}.png}
&
\noindent\sphinxincludegraphics{{bin30}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Modules}
\label{\detokenize{pages/modules:modules}}\label{\detokenize{pages/modules::doc}}

\section{lmd.lib}
\label{\detokenize{pages/modules:lmd-lib}}

\subsection{Collection}
\label{\detokenize{pages/modules:collection}}\index{Collection (class in lmd.lib)@\spxentry{Collection}\spxextra{class in lmd.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{lmd.lib.}}\sphinxbfcode{\sphinxupquote{Collection}}}{\emph{\DUrole{n}{calibration\_points}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Class which is used for creating shape collections for the Leica LMD6 \& 7. Contains a coordinate system defined by calibration points and a collection of various shapes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calibration\_points}} \textendash{} Calibration coordinates in the form of \((3, 2)\).

\end{description}\end{quote}
\index{shapes (lmd.lib.Collection attribute)@\spxentry{shapes}\spxextra{lmd.lib.Collection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.shapes}}\pysigline{\sphinxbfcode{\sphinxupquote{shapes}}}
\sphinxAtStartPar
Contains all shapes which are part of the collection.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
List{[}Shape{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{calibration\_points (lmd.lib.Collection attribute)@\spxentry{calibration\_points}\spxextra{lmd.lib.Collection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.calibration_points}}\pysigline{\sphinxbfcode{\sphinxupquote{calibration\_points}}}
\sphinxAtStartPar
Calibration coordinates in the form of \((3, 2)\).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
Optional{[}np.ndarray{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{orientation\_transform (lmd.lib.Collection attribute)@\spxentry{orientation\_transform}\spxextra{lmd.lib.Collection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.orientation_transform}}\pysigline{\sphinxbfcode{\sphinxupquote{orientation\_transform}}}
\sphinxAtStartPar
defines transformations performed on the provided coordinate system prior to export as XML. This orientation\_transform is always applied to shapes when there is no individual orienation\_transform provided.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_shape() (lmd.lib.Collection method)@\spxentry{add\_shape()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.add_shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_shape}}}{\emph{\DUrole{n}{shape}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{lmd.lib.Shape}}}{}
\sphinxAtStartPar
Add a new shape to the collection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shape}} \textendash{} Shape which should be added.

\end{description}\end{quote}

\end{fulllineitems}

\index{join() (lmd.lib.Collection method)@\spxentry{join()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.join}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{join}}}{\emph{\DUrole{n}{collection}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{lmd.lib.Collection}}}{}
\sphinxAtStartPar
Join the collection with the shapes of a different collection. The calibration markers of the current collection are kept. Please keep in mind that coordinate systems and calibration points must be compatible for correct joining of collections.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{collection}} \textendash{} Collection which should be joined with the current collection object.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns self

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (lmd.lib.Collection method)@\spxentry{load()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{\emph{\DUrole{n}{file\_location}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{}
\sphinxAtStartPar
Can be used to load a shape file from XML. Both, XMLs generated with py\sphinxhyphen{}lmd and the Leica software can be used.
:param file\_location: File path pointing to the XML file.

\end{fulllineitems}

\index{new\_shape() (lmd.lib.Collection method)@\spxentry{new\_shape()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.new_shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{new\_shape}}}{\emph{\DUrole{n}{points}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{well}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{name}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Directly create a new Shape in the current collection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{points}} \textendash{} Array or list of lists in the shape of \sphinxtitleref{(N,2)}. Contains the points of the polygon forming a shape.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{well}} \textendash{} Well in which to sort the shape after cutting. For example A1, A2 or B3.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of the shape.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (lmd.lib.Collection method)@\spxentry{plot()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{\DUrole{n}{calibration}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{True}}, \emph{\DUrole{n}{mode}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}line\textquotesingle{}}}, \emph{\DUrole{n}{fig\_size}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{tuple}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{(5, 5)}}, \emph{\DUrole{n}{apply\_orientation\_transform}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{True}}, \emph{\DUrole{n}{apply\_scale}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{save\_name}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
This function can be used to plot all shapes of the corresponding shape collection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calibration}} \textendash{} Controls wether the calibration points should be plotted as crosshairs. Deactivating the crosshairs will result in the size of the canvas adapting to the shapes. Can be especially usefull for small shapes or debugging.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fig\_size}} \textendash{} Defaults to \((10, 10)\) Controls the size of the matplotlib figure. See \sphinxhref{https://matplotlib.org/stable/api/\_as\_gen/matplotlib.pyplot.figure.html\#matplotlib-pyplot-figure}{matplotlib documentation} for more information.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{apply\_orientation\_transform}} \textendash{} Define wether the orientation transform should be applied before plotting.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{(}}\sphinxstyleliteralstrong{\sphinxupquote{Optional}}\sphinxstyleliteralstrong{\sphinxupquote{{[}}}\sphinxstyleliteralstrong{\sphinxupquote{str}}\sphinxstyleliteralstrong{\sphinxupquote{{]}}} (\sphinxstyleliteralemphasis{\sphinxupquote{save\_name}}) \textendash{} None): Specify a filename  for saving the generated figure. By default \sphinxtitleref{None} is provided which will not save a figure.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} None): Specify a filename  for saving the generated figure. By default \sphinxtitleref{None} is provided which will not save a figure.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (lmd.lib.Collection method)@\spxentry{save()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{file\_location}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{encoding}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}utf\sphinxhyphen{}8\textquotesingle{}}}}{}
\sphinxAtStartPar
Can be used to save the shape collection as XML file.

\sphinxAtStartPar
file\_location: File path pointing to the XML file.

\end{fulllineitems}

\index{stats() (lmd.lib.Collection method)@\spxentry{stats()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.stats}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stats}}}{}{}
\sphinxAtStartPar
Print statistics about the Collection in the form of:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{==}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Collection} \PYG{n}{Stats} \PYG{o}{==}\PYG{o}{==}\PYG{o}{=}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{shapes}\PYG{p}{:} \PYG{l+m+mi}{208}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertices}\PYG{p}{:} \PYG{l+m+mi}{126}\PYG{p}{,}\PYG{l+m+mi}{812}
\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{n}{Mean} \PYG{n}{vertices}\PYG{p}{:} \PYG{l+m+mf}{609.67}
\PYG{n}{Min} \PYG{n}{vertices}\PYG{p}{:} \PYG{l+m+mf}{220.00}
\PYG{l+m+mi}{5}\PYG{o}{\PYGZpc{}} \PYG{n}{percentile} \PYG{n}{vertices}\PYG{p}{:} \PYG{l+m+mf}{380.20}
\PYG{n}{Median} \PYG{n}{vertices}\PYG{p}{:} \PYG{l+m+mf}{594.00}
\PYG{l+m+mi}{95}\PYG{o}{\PYGZpc{}} \PYG{n}{percentile} \PYG{n}{vertices}\PYG{p}{:} \PYG{l+m+mf}{893.20}
\PYG{n}{Max} \PYG{n}{vertices}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{300.00}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{svg\_to\_lmd() (lmd.lib.Collection method)@\spxentry{svg\_to\_lmd()}\spxextra{lmd.lib.Collection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Collection.svg_to_lmd}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{svg\_to\_lmd}}}{\emph{\DUrole{n}{file\_location}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{{[}0, 0{]}}}, \emph{\DUrole{n}{divisor}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{multiplier}\DUrole{o}{=}\DUrole{default_value}{60}}, \emph{\DUrole{n}{rotation\_matrix}\DUrole{o}{=}\DUrole{default_value}{numpy.eye}}, \emph{\DUrole{n}{orientation\_transform}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Can be used to save the shape collection as XML file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_location}} \textendash{} File path pointing to the SVG file.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{orientation\_transform}} \textendash{} Will superseed the global transform of the Collection.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotation\_matrix}} \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Shape}
\label{\detokenize{pages/modules:shape}}\index{Shape (class in lmd.lib)@\spxentry{Shape}\spxextra{class in lmd.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{lmd.lib.}}\sphinxbfcode{\sphinxupquote{Shape}}}{\emph{\DUrole{n}{points}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{well}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{name}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{orientation\_transform}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Class for creating a single shape object.
\index{from\_xml() (lmd.lib.Shape method)@\spxentry{from\_xml()}\spxextra{lmd.lib.Shape method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Shape.from_xml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_xml}}}{\emph{\DUrole{n}{root}}}{}
\sphinxAtStartPar
Load a shape from an XML shape node. Used internally for reading LMD generated XML files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{root}} \textendash{} XML input node.

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_xml() (lmd.lib.Shape method)@\spxentry{to\_xml()}\spxextra{lmd.lib.Shape method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.Shape.to_xml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_xml}}}{\emph{\DUrole{n}{id}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{orientation\_transform}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{scale}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}
\sphinxAtStartPar
Generate XML shape node needed internally for export.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} Sequential identifier of the shape as used in the LMD XML format.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{orientation\_transform}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Pass orientation\_transform which is used if no local orientation transform is set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Scalling factor used to enable higher decimal precision.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If the Shape has a custom orientation\_transform defined, the custom orientation\_transform is applied at this point. If not, the oritenation\_transform passed by the parent Collection is used. This highlights an important difference between the Shape and Collection class. The Collection will always has an orientation transform defined and will use \sphinxtitleref{np.eye(2)} by default. The Shape object can have a orientation\_transform but can also be set to \sphinxtitleref{None} to use the Collection value.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}



\subsection{SegmentationLoader}
\label{\detokenize{pages/modules:segmentationloader}}\index{SegmentationLoader (class in lmd.lib)@\spxentry{SegmentationLoader}\spxextra{class in lmd.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.SegmentationLoader}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{lmd.lib.}}\sphinxbfcode{\sphinxupquote{SegmentationLoader}}}{\emph{\DUrole{n}{config}\DUrole{o}{=}\DUrole{default_value}{\{\}}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Select single cells from a segmentation and generate cutting data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dict containing configuration parameters. See Note for further explanation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cell\_sets}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} List of dictionaries containing the sets of cells which should be sorted into a single well.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calibration\_marker}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Array of size ‘(3,2)’ containing the calibration marker coordinates in the ‘(row, column)’ format.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{SegmentationLoader}

\PYG{n}{im} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{segmentation\PYGZus{}cytosol.tiff}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{segmentation} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{im}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{uint32}\PYG{p}{)}

\PYG{n}{all\PYGZus{}classes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{segmentation}\PYG{p}{)}

\PYG{n}{cell\PYGZus{}sets} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{classes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{all\PYGZus{}classes}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{well}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}

\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{loader\PYGZus{}config} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orientation\PYGZus{}transform}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}

\PYG{n}{sl} \PYG{o}{=} \PYG{n}{SegmentationLoader}\PYG{p}{(}\PYG{n}{config} \PYG{o}{=} \PYG{n}{loader\PYGZus{}config}\PYG{p}{)}
\PYG{n}{shape\PYGZus{}collection} \PYG{o}{=} \PYG{n}{sl}\PYG{p}{(}\PYG{n}{segmentation}\PYG{p}{,}
                    \PYG{n}{cell\PYGZus{}sets}\PYG{p}{,}
                    \PYG{n}{calibration\PYGZus{}points}\PYG{p}{)}

\PYG{n}{shape\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{fig\PYGZus{}size} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{segmentation1}.png}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Basic explanation of the parameters in the config dict:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} dilation of the cutting mask in pixel before intersecting shapes in a selection group are merged}
\PYG{n+nt}{shape\PYGZus{}dilation}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{0}

\PYG{c+c1}{\PYGZsh{} erosion of the cutting mask in pixel before intersecting shapes in a selection group are merged}
\PYG{n+nt}{shape\PYGZus{}erosion}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{0}

\PYG{c+c1}{\PYGZsh{} Cutting masks are transformed by binary dilation and erosion}
\PYG{n+nt}{binary\PYGZus{}smoothing}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{3}

\PYG{c+c1}{\PYGZsh{} number of datapoints which are averaged for smoothing}
\PYG{c+c1}{\PYGZsh{} the resoltion of datapoints is twice as high as the resolution of pixel}
\PYG{n+nt}{convolution\PYGZus{}smoothing}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{15}

\PYG{c+c1}{\PYGZsh{} fold reduction of datapoints for compression}
\PYG{n+nt}{poly\PYGZus{}compression\PYGZus{}factor}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{30}

\PYG{c+c1}{\PYGZsh{} Optimization of the cutting path inbetween shapes}
\PYG{c+c1}{\PYGZsh{} optimized paths improve the cutting time and the microscopes focus}
\PYG{c+c1}{\PYGZsh{} valid options are [\PYGZdq{}none\PYGZdq{}, \PYGZdq{}hilbert\PYGZdq{}, \PYGZdq{}greedy\PYGZdq{}]}
\PYG{n+nt}{path\PYGZus{}optimization}\PYG{p}{:}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hilbert}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Paramter required for hilbert curve based path optimization.}
\PYG{c+c1}{\PYGZsh{} Defines the order of the hilbert curve used, which needs to be tuned with the total cutting area.}
\PYG{c+c1}{\PYGZsh{} For areas of 1 x 1 mm we recommend at least p = 4,  for whole slides we recommend p = 7.}
\PYG{n+nt}{hilbert\PYGZus{}p}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{7}

\PYG{c+c1}{\PYGZsh{} Parameter required for greedy path optimization.}
\PYG{c+c1}{\PYGZsh{} Instead of a global distance matrix, the k nearest neighbours are approximated.}
\PYG{c+c1}{\PYGZsh{} The optimization problem is then greedily solved for the known set of nearest neighbours until the first set of neighbours is exhausted.}
\PYG{c+c1}{\PYGZsh{} Established edges are then removed and the nearest neighbour approximation is recursivly repeated.}
\PYG{n+nt}{greedy\PYGZus{}k}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{20}

\PYG{c+c1}{\PYGZsh{} Overlapping shapes are merged based on a nearest neighbour heuristic.}
\PYG{c+c1}{\PYGZsh{} All selected shapes closer than distance\PYGZus{}heuristic pixel are checked for overlap.}
\PYG{n+nt}{distance\PYGZus{}heuristic}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{300}
\end{sphinxVerbatim}
\end{sphinxadmonition}
\index{check\_cell\_set\_sanity() (lmd.lib.SegmentationLoader method)@\spxentry{check\_cell\_set\_sanity()}\spxextra{lmd.lib.SegmentationLoader method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.SegmentationLoader.check_cell_set_sanity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_cell\_set\_sanity}}}{\emph{\DUrole{n}{cell\_set}}}{}
\sphinxAtStartPar
Check if cell\_set dictionary contains the right keys

\end{fulllineitems}

\index{load\_classes() (lmd.lib.SegmentationLoader method)@\spxentry{load\_classes()}\spxextra{lmd.lib.SegmentationLoader method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.lib.SegmentationLoader.load_classes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_classes}}}{\emph{\DUrole{n}{cell\_set}}}{}
\sphinxAtStartPar
Identify cell class definition and load classes

\sphinxAtStartPar
Identify if cell classes are provided as list of integers or as path pointing to a csv file.
Depending on the type of the cell set, the classes are loaded and returned for selection.

\end{fulllineitems}


\end{fulllineitems}



\section{lmd.tools}
\label{\detokenize{pages/modules:module-lmd.tools}}\label{\detokenize{pages/modules:lmd-tools}}\index{module@\spxentry{module}!lmd.tools@\spxentry{lmd.tools}}\index{lmd.tools@\spxentry{lmd.tools}!module@\spxentry{module}}\index{ellipse() (in module lmd.tools)@\spxentry{ellipse()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.ellipse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{ellipse}}}{\emph{\DUrole{n}{major\_axis}}, \emph{\DUrole{n}{minor\_axis}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}, \emph{\DUrole{n}{rotation}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{polygon\_resolution}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\sphinxAtStartPar
Get a lmd.lib.Shape for ellipse of choosen dimensions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{major\_axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Major axis of the ellipse. The major axis is defined from the center to the perimeter and therefore half the diameter. The major axis is placed along the x\sphinxhyphen{}axis before rotation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{minor\_axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minor axis of the ellipse. The minor axis is defined from the center to the perimeter and therefore half the diameter. The minor axis is placed along the y\sphinxhyphen{}axis before rotation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the ellipse based on the center given in the form of \sphinxtitleref{(x, y)}. Default value: np.array((0, 0))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotation}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Clockwise rotation in radian.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{polygon\_resolution}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The polygon resolution defines how far the vertices should be spaced on average. A polygon\_resolution of 10 will place a vertex on average every ten units.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Shape which contains the ellipse.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
lmd.lib.Shape

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{my\PYGZus{}ellipse} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{ellipse}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{offset} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,} \PYG{n}{polygon\PYGZus{}resolution} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{add\PYGZus{}shape}\PYG{p}{(}\PYG{n}{my\PYGZus{}ellipse}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{tools.ellipse.example}.png}

\end{fulllineitems}

\index{get\_rotation\_matrix() (in module lmd.tools)@\spxentry{get\_rotation\_matrix()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.get_rotation_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{get\_rotation\_matrix}}}{\emph{\DUrole{n}{angle}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{float}}}{}
\sphinxAtStartPar
Returns a rotation matrix for clockwise rotation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{angle}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Rotation in radian.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Matrix in the shape of (2, 2).

\item[{Return type}] \leavevmode
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{glyph() (in module lmd.tools)@\spxentry{glyph()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.glyph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{glyph}}}{\emph{\DUrole{n}{glyph}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{numpy.array}}, \emph{\DUrole{n}{rotation}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{divisor}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{multiplier}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Get an uncalibrated lmd.lib.Collection for a glyph of interest.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{glyph}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Single glyph as string.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{divisor}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Parameter which determines the resolution when creating a polygon from a SVG. A larger divisor will lead to fewer datapoints for the glyph. Default value: 10

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the glyph based on the top left corner. Default value: np.array((0, 0))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{multiplier}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Scaling parameter for defining the size of the glyph. The default height of a glyph is 10 units. Default value: 1

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Uncalibrated Collection which contains the Shapes for the glyph.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
lmd.lib.Collection

\end{description}\end{quote}

\end{fulllineitems}

\index{glyph\_path() (in module lmd.tools)@\spxentry{glyph\_path()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.glyph_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{glyph\_path}}}{\emph{\DUrole{n}{glyph}}}{}
\sphinxAtStartPar
Returns the path for a glyph of interest. Raises a NotImplementedError if an unknown glyph is requested.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{glyph}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Single glyph as string.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Path for the glyph.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{makeCross() (in module lmd.tools)@\spxentry{makeCross()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.makeCross}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{makeCross}}}{\emph{\DUrole{n}{center}}, \emph{\DUrole{n}{arms}}, \emph{\DUrole{n}{width}}, \emph{\DUrole{n}{dist}}}{}
\sphinxAtStartPar
Generate lmd.lib.Shapes to represent a crosshair and add them to an exisiting lmd.lib.Collection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{center}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.array}}) \textendash{} center of the new crosshair

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{arms}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.array}}) \textendash{} length of the individual arms {[}top, right, bottom, left{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{width}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} width of each individual element of the crosshair

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} distance between the center of the cross hair and each arm

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Uncalibrated Collection which contains the Shapes for the calibration cross.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
lmd.lib.Collection

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{cross\PYGZus{}1} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{makeCross}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{cross\PYGZus{}1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=0.5]{{tools.makeCross.example}.png}

\end{fulllineitems}

\index{rectangle() (in module lmd.tools)@\spxentry{rectangle()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.rectangle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{rectangle}}}{\emph{\DUrole{n}{width}}, \emph{\DUrole{n}{height}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}, \emph{\DUrole{n}{rotation}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{rotation\_offset}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}}{}
\sphinxAtStartPar
Get a lmd.lib.Shape for rectangle of choosen dimensions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{width}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Width of the rectangle.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the rectangle based on the center. Default value: np.array((0, 0))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotation}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Rotation in radian.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotation\_offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the center of rotation relative to the center of the rectangle. Default value: np.array((0, 0))

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Shape which contains the rectangle.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
lmd.lib.Shape

\end{description}\end{quote}

\sphinxAtStartPar
Example:

\end{fulllineitems}

\index{text() (in module lmd.tools)@\spxentry{text()}\spxextra{in module lmd.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pages/modules:lmd.tools.text}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{lmd.tools.}}\sphinxbfcode{\sphinxupquote{text}}}{\emph{\DUrole{n}{text}}, \emph{\DUrole{n}{offset}\DUrole{o}{=}\DUrole{default_value}{numpy.array}}, \emph{\DUrole{n}{divisor}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{multiplier}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{rotation}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Get an uncalibrated lmd.lib.Collection for a text.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{text}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Text as string.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{divisor}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Parameter which determines the resolution when creating a polygon from a SVG. A larger divisor will lead to fewer datapoints for the glyph. Default value: 10

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Location of the text based on the top left corner. Default value: np.array((0, 0))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{multiplier}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Scaling parameter for defining the size of the text. The default height of a glyph is 10 units. Default value: 1

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Uncalibrated Collection which contains the Shapes for the text.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
lmd.lib.Collection

\end{description}\end{quote}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{lmd}\PYG{n+nn}{.}\PYG{n+nn}{lib} \PYG{k+kn}{import} \PYG{n}{Collection}\PYG{p}{,} \PYG{n}{Shape}
\PYG{k+kn}{from} \PYG{n+nn}{lmd} \PYG{k+kn}{import} \PYG{n}{tools}

\PYG{n}{calibration} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection} \PYG{o}{=} \PYG{n}{Collection}\PYG{p}{(}\PYG{n}{calibration\PYGZus{}points} \PYG{o}{=} \PYG{n}{calibration}\PYG{p}{)}

\PYG{n}{identifier\PYGZus{}1} \PYG{o}{=} \PYG{n}{tools}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0456\PYGZus{}B2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{offset}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rotation} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{identifier\PYGZus{}1}\PYG{p}{)}
\PYG{n}{my\PYGZus{}first\PYGZus{}collection}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{calibration} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[scale=1.0]{{fig10}.png}

\end{fulllineitems}




\renewcommand{\indexname}{Index}
\printindex
\end{document}